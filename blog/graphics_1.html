---
title: Canvas graphics
---

{% include canvas_css.html %}
{% include code_css.html %}

<br/>

<p>Surfing the internet, I found a <a>video by Tsoding ()</a> where he writes a quick program to draw points in a canvas HTML element using JavaScript. The interesting part is that he creates a 3D effect by adding a perspective projection to the points before drawing them to the canvas. The formula is very simple, just scale down the X and Y coordinates of the point in the canvas according to their position in the Z direction (the direction perpendicular to the canvas):</p>

<p>This looked quite cool, so I wanted to implement it myself from scratch. I have never properly coded in JavaScript, so this would be simple program to learn a bit the language. I was not very fond of the API that Tsoding wrote, so I wanted to write an API I could ideally use more generally (the idea maybe being I could use it to create a plotting library on top of it?). The things I wanted to achieve were:</p>

<ul>
    <li>Create an API that lets me draw points and edges connecting them on a canvas.</li>
    <li>Be able to apply different kinds of projections to the points.</li>
    <li>Animate the position of the points.</li>
</ul>

Let's see what I achieved!

<h3 class="pt-2">Drawing points and edges</h3>

<p>A</p>

{% highlight javascript mark_lines="5" %}
const coords = new CoordSystem(new Range(-1, 1), new Range(-1, 1));
console.log(coords.toCanvasCoords(myCanvas, new Point(0, 0)));
console.log(coords.toCanvasCoords(myCanvas, new Point(0, 1)));
console.log(coords.toCanvasCoords(myCanvas, new Point(0, -1)));
console.log(coords.toCanvasCoords(myCanvas, new Point(0, 2)));
var drawToScreen = new DrawToScreen(myCanvas, coords);
drawToScreen.addPoint(new Point(0, 0));
drawToScreen.addPoint(new Point(0, 0.5));
drawToScreen.printPoints();
{% endhighlight %}

<div class="codeResult">
    <p>Some text</p>
    <p>Some text</p>
</div>

<canvas id="drawPointsCanvas"></canvas>

<!-- Range slider to track time -->
<label for="customRange2" class="form-label">Example range</label>
<input type="range" class="form-range" min="0" max="5" id="customRange2">

<canvas id="myCanvas" width="500" height="500" ></canvas>


<script src="{{ '/assets/js/personal/graphics.js' | absolute_url }}"></script>
<script>
    ctx = drawPointsCanvas.getContext("2d");
    ctx.fillStyle = "lightgrey";
    ctx.fillRect(0, 0, drawPointsCanvas.width, drawPointsCanvas.height);
    const coords = new CoordSystem(new Range(-1, 1), new Range(-1, 1));
    console.log(coords.toCanvasCoords(myCanvas, new Point(0, 0)));
    console.log(coords.toCanvasCoords(myCanvas, new Point(0, 1)));
    console.log(coords.toCanvasCoords(myCanvas, new Point(0, -1)));
    console.log(coords.toCanvasCoords(myCanvas, new Point(0, 2)));
    var drawToScreen = new DrawToScreen(myCanvas, coords);
    drawToScreen.addPoint(new Point(0, 0));
    drawToScreen.addPoint(new Point(0, 0.5));
    // drawToScreen.printPoints();

    function perspectiveProjection(point) {
        return new Point(point.x/point.z, point.y/point.z);
    }

    function moveAway(point) {
        return new Point(point.x, point.y, point.z+0.01);
    }

    function rotateY(point, angle) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const x = point.x * cosA - point.z * sinA;
        const z = point.x * sinA + point.z * cosA;
        return new Point(x, point.y, z);
    }

    function rotateYaroundP(point, angle, rotationPoint) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const offsetX = point.x - rotationPoint.x;
        const offsetZ = point.z - rotationPoint.z;
        const x = offsetX * cosA - offsetZ * sinA + rotationPoint.x;
        const z = offsetX * sinA + offsetZ * cosA + rotationPoint.z;
        return new Point(x, point.y, z);
    }

    function rotateZ(point, angle) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const x = point.x * cosA - point.y * sinA;
        const y = point.x * sinA + point.y * cosA;
        return new Point(x, y, point.z);
    }

    function rotateZaroundP(point, angle, rotationPoint) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const offsetX = point.x - rotationPoint.x;
        const offsetY = point.y - rotationPoint.y; 
        const x = offsetX * cosA - offsetY * sinA + rotationPoint.x;
        const y = offsetX * sinA + offsetY * cosA + rotationPoint.y;
        const newP = new Point(x, y, point.z);
        console.log(newP); 
        return newP;
    }

    function round(x) {
        return Math.round(x * 10000) / 10000;
    }

    function rotateXaroundP(point, angle, rotationPoint) {
        const cosA = new Decimal(angle).cosine();
        const sinA = new Decimal(angle).sine();
        const offsetY = new Decimal(point.y).minus(rotationPoint.y);
        const offsetZ = new Decimal(point.z).minus(rotationPoint.z);
        // console.log(offsetY, offsetZ);
        const y = offsetY.mul(cosA).minus(offsetZ.times(sinA)).plus(rotationPoint.y);
        const z = offsetY.times(sinA).plus(offsetZ.times(cosA)).plus(rotationPoint.z);
        const newP = new Point(point.x, y.toNumber(), z.toNumber());
        // console.log(newP); 
        return newP;
    }

    const coords2 = new CoordSystem(new Range(-1, 1), new Range(-1, 1), perspectiveProjection);
    var drawToScreen2 = new DrawToScreen(myCanvas, coords2);
    drawToScreen2.addPoint(new Point(1, 1, -1), "green");
    drawToScreen2.addPoint(new Point(1, -1, -1), "green");
    drawToScreen2.addPoint(new Point(-1, -1, -1), "green");
    drawToScreen2.addPoint(new Point(-1, 1, -1), "green");
    drawToScreen2.addPoint(new Point(1, 1, 1), "green");
    drawToScreen2.addPoint(new Point(1, -1, 1), "green");
    drawToScreen2.addPoint(new Point(-1, -1, 1), "green");
    drawToScreen2.addPoint(new Point(-1, 1, 1), "green");
    drawToScreen2.addPoint(new Point(0, 0, 0), "red");
    drawToScreen2.addEdge(0, 1);
    drawToScreen2.addEdge(1, 2);
    drawToScreen2.addEdge(2, 3);
    drawToScreen2.addEdge(3, 0);
    drawToScreen2.addEdge(4, 5);
    drawToScreen2.addEdge(5, 6);
    drawToScreen2.addEdge(6, 7);
    drawToScreen2.addEdge(7, 4);
    drawToScreen2.addEdge(0, 4);
    drawToScreen2.addEdge(1, 5);
    drawToScreen2.addEdge(2, 6);
    drawToScreen2.addEdge(3, 7);

    const FPS = 60;
    var t = 3;
    var step = 0.01;
    const maxT = 60;
    // var points = [
    // Point(1, 1, 3),
    // Point(1, -1, 3),
    // Point(-1, -1, 3),
    // Point(-1, 1, 3),
    // Point(1, 1, 5),
    // Point(1, -1, 5),
    // Point(-1, -1, 5),
    // Point(-1, 1, 5),
    // ];
    function newPosAtT(p, t) {
        const newP = new Point(p.x, p.y, p.z+1*t);
        // const cosA = Math.cos(10*t);
        // const sinA = Math.sin(10*t);
        // const offsetX = p.x;
        // const offsetZ = p.z;
        // const x = offsetX * cosA - offsetZ * sinA;
        // const z = offsetX * sinA + offsetZ * cosA;
        // var newP = new Point(x, p.y, z);
        // newP.z += 4*t + 5;
        return newP;
    }
    drawToScreen2.addFunc(newPosAtT);

    const timeSlider = document.getElementById("customRange2");
    timeSlider.addEventListener("input", (event) => {
        t = parseFloat(event.target.value);
    });
    timeSlider.value = t;
    timeSlider.min = 3;
    timeSlider.max = maxT;
    timeSlider.step = step;

    function printLoop() {
        drawToScreen2.clearCanvas();
        drawToScreen2.print(time=t);
        // function newPosAtT(p) {
        //     // const newP = new Point(p.x, p.y, p.z+0.1*t);
        //     const cosA = Math.cos(10*t);
        //     const sinA = Math.sin(10*t);
        //     const offsetX = p.x;
        //     const offsetZ = p.z;
        //     const x = offsetX * cosA - offsetZ * sinA;
        //     const z = offsetX * sinA + offsetZ * cosA;
        //     var newP = new Point(x, p.y, z);
        //     newP.z += 4/t + 5;
        //     return newP;
        // }
        // drawToScreen2.printPointsAfterTransform(newPosAtT);
        // drawToScreen2.printEdges();
        // drawToScreen2.updatePositions(moveAway);
        // drawToScreen2.updatePositions((point) => rotateY(point, 0.08));
        // drawToScreen2.updatePositions((point) => rotateZ(point, 0.005));
        // drawToScreen2.updatePositions((point) => rotateZaroundP(point, 0.05, centroid(drawToScreen2.points)));
        // drawToScreen2.updatePositions((point) => rotateYaroundP(point, 0.05, centroid(drawToScreen2.points)));
        // drawToScreen2.updatePositions((point) => rotateXaroundP(point, 0.08, centroid(drawToScreen2.points)));
        // console.log(centroid(drawToScreen2.points));
        t += step;
        timeSlider.value = t;
        setTimeout(printLoop, 1000/FPS);
    }
    setTimeout(printLoop, 1000/FPS);
</script>
